Difference between find() and findOne()
Method	What it Returns	Return Type	When to Use
find()	Returns all documents that match the query	Array of objects (can be empty or have many results)	When you expect multiple users or want to loop through results
findOne()	Returns first document only that matches the query	Single object (or null if not found)	When you expect only one user or a unique record (like by email)
âš™ï¸ Example
ðŸ‘‰ User.find({ email: "john@example.com" })

MongoDB internally does this:

â€œFind all users where email is john@example.comâ€

ðŸ”¹ Result â†’ Array

[
  { _id: 1, name: "JohnDoe", email: "john@example.com" },
  { _id: 2, name: "JohnDoe", email: "john@example.com" }
]


Even if thereâ€™s only one match, it still returns inside an array:

[{ _id: 1, name: "JohnDoe", email: "john@example.com" }]


Thatâ€™s what happened in your output ðŸ‘‡
data is an array containing two users with same email.

ðŸ‘‰ User.findOne({ email: "john@example.com" })

MongoDB internally does this:

â€œFind the first user where email is john@example.com and stop searching.â€

ðŸ”¹ Result â†’ Single object (not array)

{ _id: 1, name: "JohnDoe", email: "john@example.com" }


If not found â†’ returns null.

âš ï¸ Important Detail

If your email should be unique (like a login system),
you should always use:

const user = await User.findOne({ email });


â€¦and ideally, make email a unique field in your schema:

email: { type: String, unique: true, required: true }


This ensures no duplicate users with the same email are stored.

ðŸ§© Updated version of your route

If you only expect one user per email, use this:

app.get("/user/:email", async (req, res) => {
  try {
    const { email } = req.params;

    const user = await User.findOne({ email });

    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found with this email",
      });
    }

    res.status(200).json({
      success: true,
      message: "User found successfully",
      data: user,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Internal server error",
      error: error.message,
    });
  }
});
